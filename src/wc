#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include <algorithm>
#include "arc.h"
#include "main.h"
using namespace std;

Arc::Arc(float x, float y) {
    this->x = x, this->y = y;
    this->radius = 4.0;
    this->Large = Semicircle(x, y, 4.0, 0.0, 0.0, 0.0, COLOR_PINK);
    this->Small = Semicircle(x, y, 3.5, 0.0, 0.0, 0.0, COLOR_BACKGROUND);
}

void Arc::draw(glm::mat4 VP) {
    Large.draw(VP), Small.draw(VP);
}

void Arc::tick(float speedx) {
    Large.speedx = Small.speedx = speedx;
    Large.tick(), Small.tick();
    this->x = Large.position.x, this->y = Large.position.y;
}

float Arc::Get_y(float x){
    float xcord = x - this->x;
    float ycord = sqrt(this->radius*this->radius - xcord*xcord);
    // cout<<xcord<<" "<<ycord<<endl;
    return ycord + this->y;
}
#include "main.h"
#include "semicircle.h"

#ifndef ARC_H
#define ARC_H

class Arc {
public:
    Arc() {}
    Arc(float x, float y);
    void draw(glm::mat4 VP);
    void tick(float speedx);
    float Get_y(float x);
    float x, y, speedx, speedy, radius;
    Semicircle Large, Small;
private:
    VAO *object;
};

#endif // ARC_H
#define GLM_ENABLE_EXPERIMENTAL
#include "ball.h"
#include "main.h"

Ball::Ball(float x, float y, color_t color) {
    this->position = glm::vec3(x, y, 0);
    this->rotation = 0;
    speed = 1;
    // Our vertices. Three consecutive floats give a 3D vertex; Three consecutive vertices give a triangle.
    // A cube has 6 faces with 2 triangles each, so this makes 6*2=12 triangles, and 12*3 vertices
    static const GLfloat vertex_buffer_data[] = {
        -0.5f,-0.5f,-0.5f, // triangle 1 : begin
        -0.5f,-0.5f, 0.5f,
        -0.5f, 0.5f, 0.5f, // triangle 1 : end
        0.5f, 0.5f,-0.5f, // triangle 2 : begin
        -0.5f,-0.5f,-0.5f,
        -0.5f, 0.5f,-0.5f, // triangle 2 : end
        0.5f,-0.5f, 0.5f,
        -0.5f,-0.5f,-0.5f,
        0.5f,-0.5f,-0.5f,
        0.5f, 0.5f,-0.5f,
        0.5f,-0.5f,-0.5f,
        -0.5f,-0.5f,-0.5f,
        -0.5f,-0.5f,-0.5f,
        -0.5f, 0.5f, 0.5f,
        -0.5f, 0.5f,-0.5f,
        0.5f,-0.5f, 0.5f,
        -0.5f,-0.5f, 0.5f,
        -0.5f,-0.5f,-0.5f,
        -0.5f, 0.5f, 0.5f,
        -0.5f,-0.5f, 0.5f,
        0.5f,-0.5f, 0.5f,
        0.5f, 0.5f, 0.5f,
        0.5f,-0.5f,-0.5f,
        0.5f, 0.5f,-0.5f,
        0.5f,-0.5f,-0.5f,
        0.5f, 0.5f, 0.5f,
        0.5f,-0.5f, 0.5f,
        0.5f, 0.5f, 0.5f,
        0.5f, 0.5f,-0.5f,
        -0.5f, 0.5f,-0.5f,
        0.5f, 0.5f, 0.5f,
        -0.5f, 0.5f,-0.5f,
        -0.5f, 0.5f, 0.5f,
        0.5f, 0.5f, 0.5f,
        -0.5f, 0.5f, 0.5f,
        0.5f,-0.5f, 0.5f
    };

    this->object = create3DObject(GL_TRIANGLES, 12*3, vertex_buffer_data, color, GL_FILL);
}

void Ball::draw(glm::mat4 VP) {
    Matrices.model = glm::mat4(0.5f);
    glm::mat4 translate = glm::translate (this->position);    // glTranslatef
    glm::mat4 rotate    = glm::rotate((float) (this->rotation * M_PI / 180.0f), glm::vec3(1, 0, 0));
    // No need as coords centered at 0, 0, 0 of cube arouund which we waant to rotate
    // rotate          = rotate * glm::translate(glm::vec3(0, -0.6, 0));
    Matrices.model *= (translate * rotate);
    glm::mat4 MVP = VP * Matrices.model;
    glUniformMatrix4fv(Matrices.MatrixID, 1, GL_FALSE, &MVP[0][0]);
    draw3DObject(this->object);
}

void Ball::set_position(float x, float y) {
    this->position = glm::vec3(x, y, 0);
}

void Ball::tick() {
    // this->rotation += speed;
    this->position.x -= speed;
    // this->position.y += speed;
}

#include "main.h"

#ifndef BALL_H
#define BALL_H


class Ball {
public:
    Ball() {}
    Ball(float x, float y, color_t color);
    glm::vec3 position;
    float rotation;
    void draw(glm::mat4 VP);
    void set_position(float x, float y);
    void tick();
    double speed;
private:
    VAO *object;
};

#endif // BALL_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include <algorithm>
#include "boomerang.h"
#include "main.h"
using namespace std;

Boomerang::Boomerang(float x, float y) {
    this->angle = 0.0;
    this->speedx = 0.00;
    this->speedy = -0.025;
    this->x = x, this->y = y;
    Centre1 = Rectangle(x, y, 1.0, 0.2, 45.0, 0.0, this->speedy, COLOR_TRUERED);
    Centre2 = Rectangle(x, y, 0.8, 0.2, -45.0, 0.0, this->speedy, COLOR_TRUERED);
    Top = Rectangle(x , y , 0.8, 0.2, 45.0, 0.0, 0.0, COLOR_TRUEBLACK);
    Bottom = Rectangle(x , y , 0.6, 0.2, -45.0, 0.0, 0.0, COLOR_TRUEBLACK);
}

void Boomerang::draw(glm::mat4 VP) {
    Centre1.draw(VP);
    Centre2.draw(VP);
    Top.draw(VP);
    Bottom.draw(VP);
}

int Boomerang::tick(float speedx) {
    speedx *= -1.0;    this->speedx = 2.0*(this->y - 5.3)*this->speedy;
    Centre1.speedx = Centre2.speedx = Top.speedx = Bottom.speedx = -1.0*(this->speedx);
    Centre1.speedy = Centre2.speedy = Top.speedy = Bottom.speedy = this->speedy;
    Centre1.rotation += 4.0;
    Centre2.rotation += 4.0;
    Top.rotation += 4.0;
    Bottom.rotation += 4.0;
    Centre1.tick(), Centre2.tick(), Top.tick(), Bottom.tick();
    this->x = Centre1.position.x, this->y = Centre1.position.y;
    if(this->x > 15.0 && this->y < 3.0)
        return 1;
    return 0;
}
#include "main.h"
#include "rectangle.h"

#ifndef BOOMERANG_H
#define BOOMERANG_H


class Boomerang {
public:
    Boomerang() {}
    Boomerang(float x, float y);
    void draw(glm::mat4 VP);
    int tick(float background_speedx);
    float x, y, speedx, speedy, angle;
    Rectangle Top, Centre1, Centre2, Bottom;
private:
    VAO *object;
};

#endif // BOOMERANG_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "circle.h"
#include "main.h"
using namespace std;

Circle::Circle(float x, float y, float radius, float speedx, float speedy, color_t color) {
    this->position = glm::vec3(x, y, 0);
    this->speedx = speedx;
    this->speedy = speedy;
    this->radius = radius;
    const int n = 100;
    GLfloat vertex_buffer_data[9*n] ;
    float r = radius;
    float angle = ( 2.0*M_PI / float(n));
    float theta = 0.0;
    for(int i=0;i<n;i++){
        vertex_buffer_data[9*i] = 0.0f;
        vertex_buffer_data[9*i + 1] = 0.0f;
        vertex_buffer_data[9*i + 2] = 0.0f;
        vertex_buffer_data[9*i + 3] = r*cos(theta);
        vertex_buffer_data[9*i + 4] = r*sin(theta);
        vertex_buffer_data[9*i + 5] = 0.0f;
        theta += angle;
        if(i == n-1){
            vertex_buffer_data[9*i + 6] = r;
            vertex_buffer_data[9*i + 7] = 0.0f;
            vertex_buffer_data[9*i + 8] = 0.0f;
        }
        else{
            vertex_buffer_data[9*i + 6] = r*cos(theta);
            vertex_buffer_data[9*i + 7] = r*sin(theta);
            vertex_buffer_data[9*i + 8] = 0.0f;
        }
        
    }
    this->object = create3DObject(GL_TRIANGLES, 3*n, vertex_buffer_data, color, GL_FILL);
}

void Circle::draw(glm::mat4 VP) {
    Matrices.model = glm::mat4(1.0f);
    glm::mat4 translate = glm::translate (this->position);    // glTranslatef
    glm::mat4 rotate    = glm::rotate((float) (0.0 * M_PI / 180.0f), glm::vec3(1, 0, 0));
    // No need as coords centered at 0, 0, 0 of cube arouund which we waant to rotate
    // rotate          = rotate * glm::translate(glm::vec3(0, -0.6, 0));
    Matrices.model *= (translate * rotate);
    glm::mat4 MVP = VP * Matrices.model;
    glUniformMatrix4fv(Matrices.MatrixID, 1, GL_FALSE, &MVP[0][0]);
    draw3DObject(this->object);
}

void Circle::set_position(float x, float y) {
    this->position = glm::vec3(x, y, 0);
}

void Circle::tick() {
    this->position.x -= this->speedx;
}

#include "main.h"

#ifndef CIRCLE_H
#define CIRCLE_H


class Circle {
public:
    Circle() {}
    Circle(float x, float y, float radius, float speedx, float speedy, color_t color);
    glm::vec3 position;
    void draw(glm::mat4 VP);
    void set_position(float x, float y);
    void tick();
    float radius, speedx, speedy;
private:
    VAO *object;
};

#endif // CIRCLE_H
#define GLM_ENABLE_EXPERIMENTAL
#include "main.h"

const color_t COLOR_PINK = {255, 66, 204};
const color_t COLOR_TRUEBLACK = {0, 0, 0};
const color_t COLOR_TRUERED = {255, 0, 0};
const color_t COLOR_YELLOW = {255, 255, 0};
const color_t COLOR_ORANGE = {253, 106, 2};
const color_t COLOR_GREY = {100, 100, 100};
const color_t COLOR_RED = { 236, 100, 75 };
const color_t COLOR_BLUE = { 0, 0, 255};
const color_t COLOR_GOLD = {212, 175, 55};
const color_t COLOR_GREEN = { 0, 211, 50 };
const color_t COLOR_BLACK = { 52, 73, 94 };
const color_t COLOR_BACKGROUND = { 150, 200, 250 };
const color_t COLOR_SILVER = {192, 192, 192};#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "ellipse.h"
#include "main.h"
using namespace std;

Ellipse::Ellipse(float x, float y, float a, float b, float speedx, float speedy, color_t color) {
    this->position = glm::vec3(x, y, 0);
    this->speedx = speedx;
    this->speedy = speedy;
    const int n = 100;
    GLfloat vertex_buffer_data[9*n] ;
    float angle = ( 2.0*M_PI / float(n));
    float theta = 0.0;
    for(int i=0;i<n;i++){
        vertex_buffer_data[9*i] = 0.0f;
        vertex_buffer_data[9*i + 1] = 0.0f;
        vertex_buffer_data[9*i + 2] = 0.0f;
        vertex_buffer_data[9*i + 3] = a*cos(theta);
        vertex_buffer_data[9*i + 4] = b*sin(theta);
        vertex_buffer_data[9*i + 5] = 0.0f;
        theta += angle;
        if(i == n-1){
            vertex_buffer_data[9*i + 6] = a;
            vertex_buffer_data[9*i + 7] = 0.0f;
            vertex_buffer_data[9*i + 8] = 0.0f;
        }
        else{
            vertex_buffer_data[9*i + 6] = a*cos(theta);
            vertex_buffer_data[9*i + 7] = b*sin(theta);
            vertex_buffer_data[9*i + 8] = 0.0f;
        }
        
    }
    this->object = create3DObject(GL_TRIANGLES, 3*n, vertex_buffer_data, color, GL_FILL);
}

void Ellipse::draw(glm::mat4 VP) {
    Matrices.model = glm::mat4(1.0f);
    glm::mat4 translate = glm::translate (this->position);    // glTranslatef
    glm::mat4 rotate    = glm::rotate((float) (0.0 * M_PI / 180.0f), glm::vec3(1, 0, 0));
    // No need as coords centered at 0, 0, 0 of cube arouund which we waant to rotate
    // rotate          = rotate * glm::translate(glm::vec3(0, -0.6, 0));
    Matrices.model *= (translate * rotate);
    glm::mat4 MVP = VP * Matrices.model;
    glUniformMatrix4fv(Matrices.MatrixID, 1, GL_FALSE, &MVP[0][0]);
    draw3DObject(this->object);
}

void Ellipse::set_position(float x, float y) {
    this->position = glm::vec3(x, y, 0);
}

void Ellipse::tick() {
    this->position.x += this->speedx;
    this->position.y += this->speedy;
    this->speedy -= 0.01;
}

#include "main.h"

#ifndef ELLIPSE_H
#define ELLIPSE_H


class Ellipse {
public:
    Ellipse() {}
    Ellipse(float x, float y, float a, float b, float speedx, float speedy, color_t color);
    glm::vec3 position;
    void draw(glm::mat4 VP);
    void set_position(float x, float y);
    void tick();
    float a, b;
    double speedx, speedy;
private:
    VAO *object;
};

#endif // ELLIPSE_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "fire.h"
#include "main.h"
#include "circle.h"
#include "rectangle.h"
using namespace std;
#define sqr(x) ((x)*(x))

Circle S1, S2;
Rectangle R;

Fire::Fire(float leftx, float lefty, float rightx, float righty, float speedx, float speedy) {
    this->leftx = leftx;
    this->lefty = lefty;
    this->righty = righty;
    this->rightx = rightx;
    this->speedx = speedx;
    this->speedy = speedy;
    this->len = sqrt( sqr(rightx - leftx) + sqr(righty - lefty));
    this->angle = asin( (righty - lefty) / this->len );
    float degree_angle = (this->angle*180.0)/M_PI;
    S1 = Circle(leftx, lefty, 0.2, 0.0, 0.0, COLOR_GREY );
    S2 = Circle(rightx, righty, 0.2, 0.0, 0.0, COLOR_GREY );
    R = Rectangle(leftx + 0.2*sin(this->angle), lefty - 0.2*cos(this->angle), this->len, 0.4, degree_angle, 0.0, 0.0, COLOR_YELLOW);
}

void Fire::draw(glm::mat4 VP) {
	R.draw(VP);
    S1.draw(VP);
    S2.draw(VP);
}

void Fire::tick(float speedx, float speedy) {
	R.tick();
    S1.tick();
    S2.tick();
    S1.speedx = speedx, S1.speedy = speedy;
    S2.speedx = speedx, S2.speedy = speedy;
    R.speedx = speedx, R.speedy = speedy;
    this->rightx = S2.position.x;
    this->leftx = S1.position.x;
    this->lefty = S1.position.y;
    this->righty = S2.position.y;
}
#include "main.h"

#ifndef FIRE_H
#define FIRE_H


class Fire {
public:
    Fire() {}
    Fire(float leftx, float lefty, float rightx, float righty, float speedx, float speedy);
    void draw(glm::mat4 VP);
    void tick(float speedx, float speedy);
    float leftx, lefty, rightx, righty, len, angle, speedx, speedy;
private:
    VAO *object;
};

#endif // FIRE_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <cmath>
#include <fstream>
#include <vector>

#include <GL/glew.h>
#include <GLFW/glfw3.h>

#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "main.h"

bool   cannon_keyboard_input = true;
bool   drag_pan = false, old_cki;
double drag_oldx = -1, drag_oldy = -1;

using namespace std;

/* Executed when a regular key is pressed/released/held-down */
/* Prefered for Keyboard events */
void keyboard(GLFWwindow *window, int key, int scancode, int action, int mods) {
    // Function is called first on GLFW_PRESS.

    if (action == GLFW_RELEASE) {
        // switch (key) {
        // case GLFW_KEY_C:
        // rectangle_rot_status = !rectangle_rot_status;
        // break;
        // case GLFW_KEY_P:
        // triangle_rot_status = !triangle_rot_status;
        // break;
        // case GLFW_KEY_X:
        //// do something ..
        // break;
        // default:
        // break;
        // }
    } else if (action == GLFW_PRESS) {
        switch (key) {
        case GLFW_KEY_ESCAPE:
            quit(window);
            break;
        default:
            break;
        }
    }
}

/* Executed for character input (like in text boxes) */
void keyboardChar(GLFWwindow *window, unsigned int key) {
    switch (key) {
    case 'Q':
    case 'q':
        quit(window);
        break;
    // case 's':
    //     quit(window);
    //     break;
    default:
        break;
    }
}

/* Executed when a mouse button is pressed/released */
void mouseButton(GLFWwindow *window, int button, int action, int mods) {
    switch (button) {
    case GLFW_MOUSE_BUTTON_LEFT:
        if (action == GLFW_PRESS) {
            // Do something
            return;
        } else if (action == GLFW_RELEASE) {
            // Do something
        }
        break;
    // case GLFW_MOUSE_BUTTON_RIGHT:
    // if (action == GLFW_RELEASE) {
    // rectangle_rot_dir *= -1;
    // }
    // break;
    default:
        break;
    }
}

void scroll_callback(GLFWwindow *window, double xoffset, double yoffset) {
    // Do something
}
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include <algorithm>
#include "jump.h"
#include "main.h"
#include "circle.h"
using namespace std;

Jump::Jump(float y) {
    this->y = y;
    this->radius = 0.4;
    this->speedx = 0.05;
    this->speedy = 0.0;
    this->C = Circle(14.0, y, 0.4, this->speedx , 0.0, COLOR_GREEN);
}

void Jump::draw(glm::mat4 VP) {
	this->C.draw(VP);
}

int Jump::tick(float speedx) {
    if( (this->y > 1.0 + this->radius)){
        this->speedy -= 0.01;
        this->y = max((float)(1.0 + this->radius), (float)(this->y + this->speedy) );
    }
    if( abs(this->y - (1.0 + this->radius) ) <= 0.01){
        this->speedy *= -1.0;
        this->y = this->y + this->speedy;
    }
    this->C.position.y = this->y;
    this->speedx = 0.05 + speedx;
    this->C.speedx = this->speedx;
    this->C.tick();
    if(this->C.position.x < -1.0)
        return 1;
    return 0;
}
#include "main.h"
#include "circle.h"

#ifndef JUMP_H
#define JUMP_H


class Jump {
public:
    Jump() {}
    Jump(float y);
    void draw(glm::mat4 VP);
    int tick(float speedx);
    float x, y, radius, speedx, speedy;
    Circle C;
private:
    VAO *object;
};

#endif // JUMP_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "laser.h"
#include "main.h"
#include "semicircle.h"
#include "rectangle.h"
using namespace std;

Rectangle left_rect, right_rect, beam;
Semicircle left_sem, right_sem;

Laser::Laser(float y) {
    left = 1.0, right = 11.5;
	this->y = y;
	this->left = left, this->right = right;
	this->on = 0;
    left_sem = Semicircle(left, y+0.2, 0.2, 0.0, 0.0, 90, COLOR_GREY);
    left_rect = Rectangle(left, y, 0.8, 0.4, 0.0, 0.0, 0.0, COLOR_GREY);
    beam = Rectangle(left + 0.8, y, right - left - 0.8, 0.4, 0.0, 0.0, 0.0, COLOR_ORANGE);
    right_rect = Rectangle(right, y, 0.8, 0.4, 0.0, 0.0, 0.0, COLOR_GREY);
    right_sem = Semicircle(right+0.8, y+0.2, 0.2, 0.0, 0.0, 270, COLOR_GREY);
}

void Laser::draw(glm::mat4 VP) {
	left_sem.draw(VP);
	left_rect.draw(VP);
	if(this->on == 1)
		beam.draw(VP);
	right_rect.draw(VP);
	right_sem.draw(VP);
}

void Laser::tick(int lasercounter, float sign) {
	left_sem.tick();
    left_rect.tick();
    beam.tick();
    right_rect.tick();
    right_sem.tick();
    if(lasercounter == 75)
    	this->on = 1;
    else if(lasercounter == 250){
    	this->on = 0;
    	left_sem.speedy = sign*0.03;
    	right_sem.speedy = sign*0.03;
    	left_rect.speedy = sign*0.03;
    	right_rect.speedy = sign*0.03;
    }
    else if(lasercounter == 325){
    	this->on = 1;
    	this->y = left_rect.position.y;
    	beam.position.y = left_rect.position.y;
    	left_sem.speedy = 0;
    	right_sem.speedy = 0;
    	left_rect.speedy = 0;
    	right_rect.speedy = 0;
    }
}
#include "main.h"

#ifndef LASER_H
#define LASER_H


class Laser {
public:
    Laser() {}
    Laser(float y);
    void draw(glm::mat4 VP);
    void tick(int lasercounter, float sign);
    float left, right, y;
    int on;
private:
    VAO *object;
};

#endif // LASER_H
#define GLM_ENABLE_EXPERIMENTAL
#include "main.h"
#include "Lineintersection.h"
using namespace std;

bool onSegment(Point p, Point q, Point r)
{
 if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
 q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
 return true;
 return false;
}
// check if line joining p1, q1 intersects with 
// line joining p2, q2
bool doIntersect(Point p1, Point q1, Point p2, Point q2)
{
 int o1 = orientation(p1, q1, p2);
 int o2 = orientation(p1, q1, q2);
 int o3 = orientation(p2, q2, p1);
 int o4 = orientation(p2, q2, q1);
 if (o1 != o2 && o3 != o4)
 return true;
 if (o1 == 0 && onSegment(p1, p2, q1)) return true;
 if (o2 == 0 && onSegment(p1, q2, q1)) return true;
 if (o3 == 0 && onSegment(p2, p1, q2)) return true;
 if (o4 == 0 && onSegment(p2, q1, q2)) return true;
 return false;
}

int orientation(Point p1, Point p2, Point p3)
{
 float val = (p2.y - p1.y) * (p3.x - p2.x) -
 (p2.x - p1.x) * (p3.y - p2.y);
 if (val <= 0.000001 && val>= -0.000001) return 0; // colinear
 return (val > 0)? 1: 2; // clock or counterclock wise
}
#include "main.h"
#define GLM_ENABLE_EXPERIMENTAL

#ifndef LINEINTERSECTION_H
#define LINEINTERSECTION_H

struct Point{
	float x, y;
};

bool onSegment(Point p, Point q, Point r);
bool doIntersect(Point p1, Point q1, Point p2, Point q2);
int orientation(Point p1, Point p2, Point p3);

#endif // LINEINTERSECTION_H#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "magnet.h"
#include "main.h"
#include "semicircle.h"
#include "rectangle.h"
using namespace std;

Semicircle Small, Large;
Rectangle Up1, Up2, Down1, Down2;

Magnet::Magnet(float x, float y) {
    this->x = x;
    this->y = y;
    Large = Semicircle(x, y, 0.8, 0.0, 0.0, 270, COLOR_TRUERED);
    Small = Semicircle(x, y, 0.4, 0.0, 0.0, 270, COLOR_BACKGROUND);
    Up2 = Rectangle(x - 0.4, y + 0.4, 0.4, 0.4, 0.0, 0.0, 0.0, COLOR_TRUERED);
    Up1 = Rectangle(x - 0.8, y + 0.4, 0.4, 0.4, 0.0, 0.0, 0.0, COLOR_GREY);
    Down2 = Rectangle(x - 0.4, y - 0.8, 0.4, 0.4, 0.0, 0.0, 0.0, COLOR_TRUERED);
    Down1 = Rectangle(x - 0.8, y - 0.8, 0.4, 0.4, 0.0, 0.0, 0.0, COLOR_GREY);
}

void Magnet::draw(glm::mat4 VP) {
	Large.draw(VP);
    Small.draw(VP);
    Up1.draw(VP);
    Up2.draw(VP);
    Down1.draw(VP);
    Down2.draw(VP);
}

void Magnet::tick(float speedx, float speedy) {
	Large.tick();
    Small.tick();
    Up1.tick();
    Up2.tick();
    Down1.tick();
    Down2.tick();
    Large.speedx = speedx, Large.speedy = speedy;
    Small.speedx = speedx, Small.speedy = speedy;
    Up1.speedx = speedx, Up1.speedy = speedy;
    Up2.speedx = speedx, Up2.speedy = speedy;
    Down1.speedx = speedx, Down1.speedy = speedy;
    Down2.speedx = speedx, Down2.speedy = speedy;
    this->x = Large.position.x;
    this->y = Large.position.y;
}
#include "main.h"

#ifndef MAGNET_H
#define MAGNET_H


class Magnet {
public:
    Magnet() {}
    Magnet(float x, float y);
    void draw(glm::mat4 VP);
    void tick(float speedx, float speedy);
    float x, y, speedx, speedy;
private:
    VAO *object;
};

#endif // MAGNET_H
#define GLM_ENABLE_EXPERIMENTAL
#include "main.h"
#include "timer.h"
#include "ball.h"
#include "circle.h"
#include "semicircle.h"
#include "rectangle.h"
#include "laser.h"
#include "fire.h"
#include "Lineintersection.h"
#include "magnet.h"
#include "ellipse.h"
#include "jump.h"
#include "score.h"
#include "boomerang.h"
#include "arc.h"

using namespace std;

GLMatrices Matrices;
GLuint     programID;
GLFWwindow *window;

/**************************
* Customizable functions *
**************************/

Rectangle floorarr[20], Barry;
std::vector<Circle> Coinarr;
std::vector<Laser> L;
std::vector<Fire> F;
std::vector<Magnet> M;
std::vector<Ellipse> Balloon;
std::vector<Jump> J;
Score Sc;
std::vector<Boomerang> Boom;
std::vector<Arc> arc;

int busy = 0, counter = 0, lasercounter = 0, gameover = 0, ballooncounter = 0;
int lasercount = 0, firecount = 0;
int jump = 0, jumpduration = 0;
int points = 0, prevpoints = -1;
int in_arc = 0;

float screen_zoom = 1, screen_center_x = 0, screen_center_y = 0;
float camera_rotation_angle = 0;
float aspect_ratio = 1000.0/600.0;

Timer t60(1.0 / 60);

/* Render the scene with openGL */
/* Edit this function according to your assignment */
void draw() {
    // clear the color and depth in the frame buffer
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // use the loaded shader program
    // Don't change unless you know what you are doing
    glUseProgram (programID);

    // Eye - Location of camera. Don't change unless you are sure!!
    // glm::vec3 eye ( 5*cos(camera_rotation_angle*M_PI/180.0f), 0, 5*sin(camera_rotation_angle*M_PI/180.0f) );
    glm::vec3 eye (0, 0, 1);

    // Target - Where is the camera looking at.  Don't change unless you are sure!!
    glm::vec3 target (0, 0, 0);
    // Up - Up vector defines tilt of camera.  Don't change unless you are sure!!
    glm::vec3 up (0, 1, 0);

    // Compute Camera matrix (view)
    Matrices.view = glm::lookAt( eye, target, up ); // Rotating Camera for 3D
    // Don't change unless you are sure!!
    // Matrices.view = glm::lookAt(glm::vec3(0, 0, 3), glm::vec3(0, 0, 0), glm::vec3(0, 1, 0)); // Fixed camera for 2D (ortho) in XY plane

    // Compute ViewProject matrix as view/camera might not be changed for this frame (basic scenario)
    // Don't change unless you are sure!!
    glm::mat4 VP = Matrices.projection * Matrices.view;

    // Send our transformation to the currently bound shader, in the "MVP" uniform
    // For each model you render, since the MVP will be different (at least the M part)
    // Don't change unless you are sure!!
    glm::mat4 MVP;  // MVP = Projection * View * Model

    // Scene render
    if(arc.size() == 1)
        arc[0].draw(VP);
    for(int i=0;i<20;i++)
        floorarr[i].draw(VP);
    Barry.draw(VP);
    for(int i=0;i<Coinarr.size();i++)
        Coinarr[i].draw(VP);
    if(busy == 1)
        L[0].draw(VP);
    if(busy == 2)
        F[0].draw(VP);
    if(M.size() == 1)
        M[0].draw(VP);
    if(Balloon.size() == 1)
        Balloon[0].draw(VP);
    if(J.size() == 1)
        J[0].draw(VP);
    Sc.draw(VP);
    if(Boom.size() == 1)
        Boom[0].draw(VP);
}

void tick_input(GLFWwindow *window) {
    int left  = glfwGetKey(window, GLFW_KEY_LEFT);
    int right = glfwGetKey(window, GLFW_KEY_RIGHT);
    int up = glfwGetKey(window, GLFW_KEY_UP);
    int w = glfwGetKey(window, GLFW_KEY_W);
    if (left) {
        // Do something
        if(Barry.position.x >= 0.0)
            Barry.position.x -= 0.1;
    }
    if(right){
        if(Barry.position.x < 5.5)
            Barry.position.x += 0.1;
        else{
            for(int i=0;i<20;i++){
                floorarr[i].speedx = 0.2;
            }
        }
    }
    if(up && in_arc == 0){
        Barry.speedy += 0.01;
    }
    if(w){
        if(ballooncounter > 200 && Balloon.size() == 0){
            Balloon.push_back(Ellipse(Barry.position.x + 0.75, Barry.position.y + 0.5, 0.5, 0.3, 0.15, 0.15, COLOR_BLUE));
            ballooncounter = 0;
        }
    }
}

void tick_elements() {
    bounding_box_t Barrybound;
    Barrybound.x = Barry.position.x;
    Barrybound.y = Barry.position.y;
    Barrybound.height = Barry.width;
    Barrybound.width = Barry.len;

    counter++;
    lasercounter++;
    ballooncounter++;
    jumpduration++;

// Score
    if(points != prevpoints){
        Sc.tick(floorarr[0].speedx, points);
        prevpoints = points;
    }

// Boomerang
    if(Boom.size() == 0 && counter%780 == 0)
        Boom.push_back(Boomerang(16.0, 9.3));
    if(Boom.size() == 1){
        int destroy = 0;
        destroy = Boom[0].tick(floorarr[0].speedx);
        if(destroy == 1)
            Boom.erase(Boom.begin());
        bounding_box_t Boombound;
        Boombound.x = Boom[0].x, Boombound.y = Boom[0].y - 0.7;
        Boombound.height = 1.4, Boombound.width = 0.8;
        if(in_arc == 0 && detect_collision(Boombound, Barrybound))
            destroy = 2;
        if(destroy == 2)
            gameover = 1;
    }

// Arc
    if(arc.size() == 0 && counter%650 == 0)
        arc.push_back(Arc(14.0, 3.5));
    if(arc.size() == 1){
        arc[0].tick(floorarr[0].speedx);
        if( (Barry.position.x >= arc[0].x - 4.0) && (Barry.position.x <= arc[0].x + 4.0) && (Barry.position.y + 1.0 <= arc[0].y) ){
            in_arc = 1;
        }
        if(in_arc == 1 && (Barry.position.x <= arc[0].x - 4.0 || Barry.position.x >= arc[0].x + 4.0))
            in_arc = 0;
        if(in_arc == 1){
            float arc_y = arc[0].Get_y(Barry.position.x);
            Barry.position.y = arc_y - Barrybound.height;
        }
        if(arc[0].x + 4.0 <= -1.0){
            arc.erase(arc.begin());
            in_arc = 0;
        }
    }

// Jump
    if(jump == 1 && jumpduration == 300)
        jump = 0;
    if(J.size() == 1){
        bounding_box_t Ballbound;
        Ballbound.x = J[0].C.position.x - J[0].radius;
        Ballbound.y = J[0].y - J[0].radius;
        Ballbound.height = Ballbound.width = 2.0*J[0].radius;
        int destroy = 0;
        if(in_arc == 0 && detect_collision(Ballbound, Barrybound)){
            jumpduration = 0;
            jump = 1;
            destroy = 1;
        }
        if(destroy == 0)
            destroy = J[0].tick(floorarr[0].speedx);
        if(destroy == 1)
            J.erase(J.begin());
    }
    if(J.size() == 0 && counter%2000 == 0){
        float y = 3.0 + rand()%5;
        J.push_back(Jump(y));
    }
 
// Balloon
    if(Balloon.size() == 1){
        Balloon[0].tick();


        if(Balloon[0].position.y <= 1.3)
            Balloon.erase(Balloon.begin());
    }

// Enemy
    if(counter%600 == 0 && busy == 0 && 3*lasercount <= firecount){
        L.push_back(Laser(4.0 + rand()%5));
        lasercount++;
        busy = 1;
        lasercounter = 0;
    }
    else if(lasercounter == 500 && busy == 1){
        L.erase(L.begin());
        busy = 0;
    }
    if(busy == 1){
        if(L[0].y > Barry.position.y)
            L[0].tick(lasercounter, -1.0);
        else
            L[0].tick(lasercounter, 1.0);
        bounding_box_t Laserbound;
        Laserbound.x = L[0].left + 0.8;
        Laserbound.y = L[0].y;
        Laserbound.height = 0.4;
        Laserbound.width = 9.7;
        if(in_arc == 0 && jump == 0 && L[0].on == 1 && detect_collision(Laserbound, Barrybound))
            gameover = 1;
        if(Balloon.size() == 1){
            Point Line_p, Line_q;
            Point a, b, c, d;
            Line_p.x = L[0].left + 0.8, Line_p.y = L[0].y;
            Line_q.x = L[0].left + 9.7, Line_q.y = L[0].y;
            a.x = Balloon[0].position.x - 0.5, a.y = Balloon[0].position.y - 0.3;
            b.x = Balloon[0].position.x + 0.5, b.y = Balloon[0].position.y - 0.3;
            c.x = Balloon[0].position.x + 0.5, c.y = Balloon[0].position.y + 0.3;
            d.x = Balloon[0].position.x - 0.5, d.y = Balloon[0].position.y + 0.3;
            int intersect = 0;
            if(doIntersect(a, b, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(b, c, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(c, d, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(d, a, Line_p, Line_q))
                intersect = 1;
            if(intersect == 1){
                Balloon.erase(Balloon.begin());
                L.erase(L.begin());
                busy = 0;
            }
        }

    }
    if(counter%100 == 0 && busy == 0 && firecount <= 3*lasercount){
        float lefty = 1.5 + rand()%3;
        float leftx = 12.0 + rand()%3;
        float rightx = leftx + 1 + rand()%4;
        float righty = lefty + 1 + rand()%4;
        F.push_back(Fire(leftx, lefty, rightx, righty, floorarr[0].speedx, floorarr[0].speedy));
        firecount++;
        busy = 2;
    }
    if(busy == 2){
        F[0].tick(floorarr[0].speedx, floorarr[0].speedy);
        if(F[0].rightx < -1.0){
            F.erase(F.begin());
            busy = 0;
        }
        if(in_arc == 0 && jump == 0 && F.size() > 0){
            Point Line_p, Line_q;
            Point a, b, c, d;
            Line_p.x = F[0].leftx, Line_p.y = F[0].lefty;
            Line_q.x = F[0].rightx, Line_q.y = F[0].righty;
            a.x = Barrybound.x, a.y = Barrybound.y;
            b.x = Barrybound.x + Barrybound.width, b.y = Barrybound.y;
            c.x = Barrybound.x, c.y = Barrybound.y + Barrybound.height;
            d.x = Barrybound.x + Barrybound.width, d.y = Barrybound.y + Barrybound.height;
            int intersect = 0;
            if(doIntersect(a, b, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(b, c, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(c, d, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(d, a, Line_p, Line_q))
                intersect = 1;
            if(intersect == 1)
                gameover = 1;

            if(Balloon.size() == 1){
                a.x = Balloon[0].position.x - 0.5, a.y = Balloon[0].position.y - 0.3;
                b.x = Balloon[0].position.x + 0.5, b.y = Balloon[0].position.y - 0.3;
                c.x = Balloon[0].position.x + 0.5, c.y = Balloon[0].position.y + 0.3;
                d.x = Balloon[0].position.x - 0.5, d.y = Balloon[0].position.y + 0.3;
                intersect = 0;
                if(doIntersect(a, b, Line_p, Line_q))
                    intersect = 1;
                if(doIntersect(b, c, Line_p, Line_q))
                    intersect = 1;
                if(doIntersect(c, d, Line_p, Line_q))
                    intersect = 1;
                if(doIntersect(d, a, Line_p, Line_q))
                    intersect = 1;
                if(intersect == 1){
                    Balloon.erase(Balloon.begin());
                    F.erase(F.begin());
                    busy = 0;
                }
            }
        }
    }

// Magnet
    if(counter % 350 == 0 && busy != 1 && M.size() == 0){
        float x = 6.0 + rand()%8;
        float y = 2.5 + rand()%6;
        int flag = 0;
        if(busy == 2 && F.size() == 1){
            bounding_box_t Magbound;
            Magbound.x = x, Magbound.y = y;
            Magbound.width = 1.6, Magbound.height = 1.6;
            Point Line_p, Line_q;
            Point a, b, c, d;
            Line_p.x = F[0].leftx, Line_p.y = F[0].lefty;
            Line_q.x = F[0].rightx, Line_q.y = F[0].righty;
            a.x = Magbound.x, a.y = Magbound.y;
            b.x = Magbound.x + Magbound.width, b.y = Magbound.y;
            c.x = Magbound.x, c.y = Magbound.y + Magbound.height;
            d.x = Magbound.x + Magbound.width, d.y = Magbound.y + Magbound.height;
            int intersect = 0;
            if(doIntersect(a, b, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(b, c, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(c, d, Line_p, Line_q))
                intersect = 1;
            if(doIntersect(d, a, Line_p, Line_q))
                intersect = 1;
            if(intersect == 1)
                flag = 1;
        }
        if(flag == 0)
            M.push_back( Magnet(x, y) );
    }

    if(M.size() == 1){
        M[0].tick(floorarr[0].speedx, floorarr[0].speedy);
        if(in_arc == 0){
            if(M[0].x < Barry.position.x)
                Barry.position.x -= 0.05;
            else if(M[0].x > Barry.position.x)
                Barry.position.x += 0.05;
            if(M[0].y < Barry.position.y)
                Barry.position.y -= 0.05;
            else if(M[0].y > Barry.position.y)
                Barry.position.y += 0.05;
        }
        if(M[0].x < -2.0){
            M.erase(M.begin());
        }
    }

// Floor
    for(int i=0;i<20;i++){
        floorarr[i].tick();
        if(floorarr[i].position.x < -1)
            floorarr[i].position.x += 20;
        if(jump == 0 && floorarr[i].speedx - 0.02 >= 0)
            floorarr[i].speedx -= 0.02;
        if(jump == 1)
            floorarr[i].speedx = 0.5;
    }

// Barry
    Barry.tick();
    if(Barry.position.y > 1 && in_arc == 0)
        Barry.speedy -= 0.005;

// Coins
    if(Coinarr.size() == 0){
        float startx = 25 + rand()%5;
        float starty = 6 + rand()%4;
        float rows = 1 + rand()%4;
        float cols = 1 + rand()%8;
        for(int i=0;i<rows;i++)
            for(int j = 0;j<cols;j++){
                Coinarr.push_back(Circle( (startx + j)/2, (starty + i)/2 , 0.2, 0.0, 0.0, COLOR_GOLD));
            }
    }
    for(int i=0;i < Coinarr.size(); i++){
        bounding_box_t Coinbound;
        Coinbound.x = Coinarr[i].position.x-0.2;
        Coinbound.y = Coinarr[i].position.y-0.2;
        Coinbound.height = 0.4;
        Coinbound.width = 0.4;
        if(detect_collision(Coinbound, Barrybound)){
            points += 10;
            Coinarr.erase(Coinarr.begin() + i);
            i--;
        }
    }
    for(int i=0;i<Coinarr.size();i++){
        Coinarr[i].speedx = floorarr[0].speedx;
        Coinarr[i].tick();
        if(Coinarr[i].position.x <= -1.0){
            Coinarr.erase(Coinarr.begin() + i);
            i--;
        }
    }

    // camera_rotation_angle += 1;
}

/* Initialize the OpenGL rendering properties */
/* Add all the models to be created here */
void initGL(GLFWwindow *window, int width, int height) {
    /* Objects should be created before any other gl function and shaders */
    // Create the models
    float curx = 0.0;
    for(int i=0;i<20;i++){
        if(i%2==0){
            floorarr[i] = Rectangle(curx, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, COLOR_BLACK);
            curx += 1.0;
        }
        else{
            floorarr[i] = Rectangle(curx, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, COLOR_SILVER);
            curx += 1.0;
        }
    }
    Barry = Rectangle(2.5, 1.0, 0.5, 1.0, 0.0, 0.0, 0.0, COLOR_BLUE);
    Sc = Score(9.0, 7.5);
    // Ci = Circle(4.0, 4.0, 1.0, 0.0, 0.0, COLOR_BLACK);
    // J.push_back(Jump(4.0));
    // Create and compile our GLSL program from the shaders
    programID = LoadShaders("Sample_GL.vert", "Sample_GL.frag");
    // Get a handle for our "MVP" uniform
    Matrices.MatrixID = glGetUniformLocation(programID, "MVP");


    reshapeWindow (window, width, height);

    // Background color of the scene
    glClearColor (COLOR_BACKGROUND.r / 256.0, COLOR_BACKGROUND.g / 256.0, COLOR_BACKGROUND.b / 256.0, 0.0f); // R, G, B, A
    glClearDepth (1.0f);

    glEnable (GL_DEPTH_TEST);
    glDepthFunc (GL_LEQUAL);

    cout << "VENDOR: " << glGetString(GL_VENDOR) << endl;
    cout << "RENDERER: " << glGetString(GL_RENDERER) << endl;
    cout << "VERSION: " << glGetString(GL_VERSION) << endl;
    cout << "GLSL: " << glGetString(GL_SHADING_LANGUAGE_VERSION) << endl;
}


int main(int argc, char **argv) {
    srand(time(0));
    int height = 600;
    int width = (float(height)*aspect_ratio);

    window = initGLFW(width, height);

    initGL (window, width, height);
    /* Draw in loop */
    while (gameover == 0 && !glfwWindowShouldClose(window)) {
        // Process timers

        if (t60.processTick()) {
            // 60 fps
            // OpenGL Draw commands
            draw();
            // Swap Frame Buffer in double buffering
            glfwSwapBuffers(window);

            tick_elements();
            tick_input(window);
            // cout<<gameover<<endl;
        }

        // Poll for Keyboard and mouse events
        glfwPollEvents();
    }

    quit(window);
}

bool detect_collision(bounding_box_t a, bounding_box_t b) {
    return (abs(a.x - b.x) * 2 < (a.width + b.width)) &&
           (abs(a.y - b.y) * 2 < (a.height + b.height));
}

void reset_screen() {
    float top    = screen_center_y + 8 / screen_zoom;
    float bottom = screen_center_y;
    float left   = screen_center_x;
    float right  = screen_center_x + ((8*aspect_ratio) / screen_zoom);
    Matrices.projection = glm::ortho(left, right, bottom, top, 0.1f, 500.0f);
}#ifndef MAIN_H
#define MAIN_H

#include <iostream>
#include <cmath>
#include <fstream>
#include <vector>
#include <stdlib.h>

#include <GL/glew.h>
// #include <GL/glut.h>
#include <GLFW/glfw3.h>

#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtc/matrix_transform.hpp>

struct color_t {
    int r;
    int g;
    int b;
};

// nonedit.cpp
GLFWwindow *initGLFW(int width, int height);
GLuint     LoadShaders(const char *vertex_file_path, const char *fragment_file_path);
struct VAO *create3DObject(GLenum primitive_mode, int numVertices, const GLfloat *vertex_buffer_data, const GLfloat *color_buffer_data, GLenum fill_mode = GL_FILL);
struct VAO *create3DObject(GLenum primitive_mode, int numVertices, const GLfloat *vertex_buffer_data, const GLfloat red, const GLfloat green, const GLfloat blue, GLenum fill_mode = GL_FILL);
struct VAO *create3DObject(GLenum primitive_mode, int numVertices, const GLfloat *vertex_buffer_data, const color_t color, GLenum fill_mode = GL_FILL);
void       draw3DObject(struct VAO *vao);

// input.cpp
void keyboard(GLFWwindow *window, int key, int scancode, int action, int mods);
void keyboardChar(GLFWwindow *window, unsigned int key);
void mouseButton(GLFWwindow *window, int button, int action, int mods);
void scroll_callback(GLFWwindow *window, double xoffset, double yoffset);

// other_handlers.cpp
void error_callback(int error, const char *description);
void quit(GLFWwindow *window);
void reshapeWindow(GLFWwindow *window, int width, int height);

// Types
struct VAO {
    GLuint VertexArrayID;
    GLuint VertexBuffer;
    GLuint ColorBuffer;

    GLenum PrimitiveMode;
    GLenum FillMode;
    int    NumVertices;
};
typedef struct VAO VAO;

struct GLMatrices {
    glm::mat4 projection;
    glm::mat4 model;
    glm::mat4 view;
    GLuint    MatrixID;
};

extern GLMatrices Matrices;

// ---- Logic ----

enum direction_t { DIR_UP, DIR_RIGHT, DIR_DOWN, DIR_LEFT };

struct bounding_box_t {
    float x;
    float y;
    float width;
    float height;
};

bool detect_collision(bounding_box_t a, bounding_box_t b);

extern float screen_zoom, screen_center_x, screen_center_y;
void reset_screen();

// ---- Colors ----
extern const color_t COLOR_PINK;
extern const color_t COLOR_TRUEBLACK;
extern const color_t COLOR_TRUERED;
extern const color_t COLOR_YELLOW;
extern const color_t COLOR_ORANGE;
extern const color_t COLOR_GREY;
extern const color_t COLOR_RED;
extern const color_t COLOR_GOLD;
extern const color_t COLOR_BLUE;
extern const color_t COLOR_GREEN;
extern const color_t COLOR_BLACK;
extern const color_t COLOR_SILVER;
extern const color_t COLOR_BACKGROUND;

#endif
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <cmath>
#include <fstream>
#include <vector>

#include <GL/glew.h>
#include <GLFW/glfw3.h>

#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "main.h"

using namespace std;

/* Initialise glfw window, I/O callbacks and the renderer to use */
/* Nothing to Edit here */
GLFWwindow*initGLFW(int width, int height) {
    GLFWwindow *window; // window desciptor/handle

    glfwSetErrorCallback(error_callback);
    if (!glfwInit()) {
        // exit(EXIT_FAILURE);
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,                 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,                 3);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT,           GL_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    window = glfwCreateWindow(width, height, "Sample OpenGL 3.3 Application", NULL, NULL);

    if (!window) {
        glfwTerminate();
        // exit(EXIT_FAILURE);
    }

    glfwMakeContextCurrent(window);
    // Initialize GLEW, Needed in Core profile
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        cout << "Error: Failed to initialise GLEW : " << glewGetErrorString(err) << endl;
        exit (1);
    }
    glfwSwapInterval(1);

    /* --- register callbacks with GLFW --- */

    /* Register function to handle window resizes */
    /* With Retina display on Mac OS X GLFW's FramebufferSize
       is different from WindowSize */
    glfwSetFramebufferSizeCallback(window, reshapeWindow);
    glfwSetWindowSizeCallback(window, reshapeWindow);

    /* Register function to handle window close */
    glfwSetWindowCloseCallback(window, quit);

    /* Register function to handle keyboard input */
    glfwSetKeyCallback(window, keyboard);  // general keyboard input
    glfwSetCharCallback(window, keyboardChar); // simpler specific character handling

    /* Register function to handle mouse click */
    glfwSetMouseButtonCallback(window, mouseButton); // mouse button clicks
    glfwSetScrollCallback(window, scroll_callback);

    return window;
}


/* Function to load Shaders - Use it as it is */
GLuint LoadShaders(const char *vertex_file_path, const char *fragment_file_path) {

    // Create the shaders
    GLuint VertexShaderID   = glCreateShader(GL_VERTEX_SHADER);
    GLuint FragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);

    // Read the Vertex Shader code from the file
    std::string   VertexShaderCode;
    std::ifstream VertexShaderStream(vertex_file_path, std::ios::in);
    if (VertexShaderStream.is_open()) {
        std::string Line = "";
        while (getline(VertexShaderStream, Line))
            VertexShaderCode += "\n" + Line;
        VertexShaderStream.close();
    }

    // Read the Fragment Shader code from the file
    std::string   FragmentShaderCode;
    std::ifstream FragmentShaderStream(fragment_file_path, std::ios::in);
    if (FragmentShaderStream.is_open()) {
        std::string Line = "";
        while (getline(FragmentShaderStream, Line))
            FragmentShaderCode += "\n" + Line;
        FragmentShaderStream.close();
    }

    GLint Result = GL_FALSE;
    int   InfoLogLength;

    // Compile Vertex Shader
    printf("Compiling shader : %s\n", vertex_file_path);
    char const *VertexSourcePointer = VertexShaderCode.c_str();
    glShaderSource(VertexShaderID, 1, &VertexSourcePointer, NULL);
    glCompileShader(VertexShaderID);

    // Check Vertex Shader
    glGetShaderiv(VertexShaderID,  GL_COMPILE_STATUS, &Result);
    glGetShaderiv(VertexShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
    std::vector<char> VertexShaderErrorMessage(InfoLogLength);
    glGetShaderInfoLog(VertexShaderID, InfoLogLength, NULL, &VertexShaderErrorMessage[0]);
    fprintf(stdout, "%s\n", &VertexShaderErrorMessage[0]);

    // Compile Fragment Shader
    printf("Compiling shader : %s\n", fragment_file_path);
    char const *FragmentSourcePointer = FragmentShaderCode.c_str();
    glShaderSource(FragmentShaderID, 1, &FragmentSourcePointer, NULL);
    glCompileShader(FragmentShaderID);

    // Check Fragment Shader
    glGetShaderiv(FragmentShaderID,  GL_COMPILE_STATUS, &Result);
    glGetShaderiv(FragmentShaderID, GL_INFO_LOG_LENGTH, &InfoLogLength);
    std::vector<char> FragmentShaderErrorMessage(InfoLogLength);
    glGetShaderInfoLog(FragmentShaderID, InfoLogLength, NULL, &FragmentShaderErrorMessage[0]);
    fprintf(stdout,              "%s\n", &FragmentShaderErrorMessage[0]);

    // Link the program
    fprintf(stdout, "Linking program\n");
    GLuint ProgramID = glCreateProgram();
    glAttachShader(ProgramID,   VertexShaderID);
    glAttachShader(ProgramID, FragmentShaderID);
    glLinkProgram(ProgramID);

    // Check the program
    glGetProgramiv(ProgramID,     GL_LINK_STATUS, &Result);
    glGetProgramiv(ProgramID, GL_INFO_LOG_LENGTH, &InfoLogLength);
    std::vector<char> ProgramErrorMessage(max(InfoLogLength, int(1)));
    glGetProgramInfoLog(ProgramID, InfoLogLength, NULL, &ProgramErrorMessage[0]);
    fprintf(stdout, "%s\n", &ProgramErrorMessage[0]);

    glDeleteShader(VertexShaderID);
    glDeleteShader(FragmentShaderID);

    return ProgramID;
}


/* Generate VAO, VBOs and return VAO handle */
struct VAO *create3DObject(GLenum primitive_mode, int numVertices, const GLfloat *vertex_buffer_data, const GLfloat *color_buffer_data, GLenum fill_mode) {
    struct VAO *vao = new struct VAO;
    vao->PrimitiveMode = primitive_mode;
    vao->NumVertices   = numVertices;
    vao->FillMode      = fill_mode;

    // Create Vertex Array Object
    // Should be done after CreateWindow and before any other GL calls
    glGenVertexArrays(1, &(vao->VertexArrayID)); // VAO
    glGenBuffers (1, &(vao->VertexBuffer)); // VBO - vertices
    glGenBuffers (1, &(vao->ColorBuffer)); // VBO - colors

    glBindVertexArray (vao->VertexArrayID); // Bind the VAO
    glBindBuffer (GL_ARRAY_BUFFER, vao->VertexBuffer); // Bind the VBO vertices
    glBufferData (GL_ARRAY_BUFFER, 3 * numVertices * sizeof(GLfloat), vertex_buffer_data, GL_STATIC_DRAW); // Copy the vertices into VBO
    glVertexAttribPointer(
        0,                            // attribute 0. Vertices
        3,                            // size (x,y,z)
        GL_FLOAT,                     // type
        GL_FALSE,                     // normalized?
        0,                            // stride
        (void *) 0                      // array buffer offset
    );

    glBindBuffer (GL_ARRAY_BUFFER, vao->ColorBuffer); // Bind the VBO colors
    glBufferData (GL_ARRAY_BUFFER, 3 * numVertices * sizeof(GLfloat), color_buffer_data, GL_STATIC_DRAW); // Copy the vertex colors
    glVertexAttribPointer(
        1,                            // attribute 1. Color
        3,                            // size (r,g,b)
        GL_FLOAT,                     // type
        GL_FALSE,                     // normalized?
        0,                            // stride
        (void *) 0                    // array buffer offset
    );

    return vao;
}

/* Generate VAO, VBOs and return VAO handle - Common Color for all vertices */
struct VAO *create3DObject(GLenum primitive_mode, int numVertices, const GLfloat *vertex_buffer_data, const GLfloat red, const GLfloat green, const GLfloat blue, GLenum fill_mode) {
    GLfloat *color_buffer_data = new GLfloat[3 * numVertices];
    for (int i = 0; i < numVertices; i++) {
        color_buffer_data[3 * i]     = red;
        color_buffer_data[3 * i + 1] = green;
        color_buffer_data[3 * i + 2] = blue;
    }

    return create3DObject(primitive_mode, numVertices, vertex_buffer_data, color_buffer_data, fill_mode);
}

struct VAO *create3DObject(GLenum primitive_mode, int numVertices, const GLfloat *vertex_buffer_data, const color_t color, GLenum fill_mode) {
    return create3DObject(primitive_mode, numVertices, vertex_buffer_data, color.r / 256.0, color.g / 256.0, color.b / 256.0, fill_mode);
}

/* Render the VBOs handled by VAO */
void draw3DObject(struct VAO *vao) {
    // Change the Fill Mode for this object
    glPolygonMode (GL_FRONT_AND_BACK, vao->FillMode);

    // Bind the VAO to use
    glBindVertexArray (vao->VertexArrayID);

    // Enable Vertex Attribute 0 - 3d Vertices
    glEnableVertexAttribArray(0);
    // Bind the VBO to use
    glBindBuffer(GL_ARRAY_BUFFER, vao->VertexBuffer);

    // Enable Vertex Attribute 1 - Color
    glEnableVertexAttribArray(1);
    // Bind the VBO to use
    glBindBuffer(GL_ARRAY_BUFFER, vao->ColorBuffer);

    // Draw the geometry !
    glDrawArrays(vao->PrimitiveMode, 0, vao->NumVertices); // Starting from vertex 0; 3 vertices total -> 1 triangle
}
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <cmath>
#include <fstream>
#include <vector>

#include <GL/glew.h>
#include <GLFW/glfw3.h>

#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "main.h"

using namespace std;

void error_callback(int error, const char *description) {
    fprintf(stderr, "Error: %s\n", description);
}

void quit(GLFWwindow *window) {
    glfwDestroyWindow(window);
    glfwTerminate();
    exit(EXIT_SUCCESS);
}

/* Executed when window is resized to 'width' and 'height' */
/* Modify the bounds of the screen here in glm::ortho or Field of View in glm::Perspective */
void reshapeWindow(GLFWwindow *window, int width, int height) {
    int fbwidth = width, fbheight = height;
    /* With Retina display on Mac OS X, GLFW's FramebufferSize
       is different from WindowSize */
    glfwGetFramebufferSize(window, &fbwidth, &fbheight);

    // GLfloat fov = 90.0f;

    // sets the viewport of openGL renderer
    glViewport (0, 0, (GLsizei) fbwidth, (GLsizei) fbheight);

    // set the projection matrix as perspective
    /* glMatrixMode (GL_PROJECTION);
           glLoadIdentity ();
           gluPerspective (fov, (GLfloat) fbwidth / (GLfloat) fbheight, 0.1, 500.0); */
    // Store the projection matrix in a variable for future use
    // Perspective projection for 3D views
    // Matrices.projection = glm::perspective (fov, (GLfloat) fbwidth / (GLfloat) fbheight, 0.1f, 500.0f);

    // Ortho projection for 2D views
    reset_screen();
}
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "rectangle.h"
#include "main.h"
using namespace std;

Rectangle::Rectangle(float x, float y, float len, float width, float angle, float speedx, float speedy, color_t color) {
    this->position = glm::vec3(x, y, 0);
    this->rotation = angle;
    this->len = len;
    this->width = width;
    this->speedy = speedy;
    this->speedx = speedx;
    GLfloat vertex_buffer_data[] = {
      0.0f, 0.0f, 0.0f,         
      len, 0.0f, 0.0f,          
      0.0f, width, 0.0f,         
      len, 0.0f, 0.0f,          
      0.0f, width, 0.0f,
      len, width, 0.0f,
    };

    this->object = create3DObject(GL_TRIANGLES, 6, vertex_buffer_data, color, GL_FILL);
}

void Rectangle::draw(glm::mat4 VP) {
    Matrices.model = glm::mat4(1.0f);
    glm::mat4 translate = glm::translate (this->position);    // glTranslatef
    glm::mat4 rotate    = glm::rotate((float) (this->rotation * M_PI / 180.0f), glm::vec3(0, 0, 1));
    // No need as coords centered at 0, 0, 0 of cube arouund which we waant to rotate
    // rotate          = rotate * glm::translate(glm::vec3(0, -0.6, 0));
    Matrices.model *= (translate * rotate);
    glm::mat4 MVP = VP * Matrices.model;
    glUniformMatrix4fv(Matrices.MatrixID, 1, GL_FALSE, &MVP[0][0]);
    draw3DObject(this->object);
}

void Rectangle::set_position(float x, float y) {
    this->position = glm::vec3(x, y, 0);
}

void Rectangle::tick() {
    this->position.x -= speedx;
    if(this->position.y  + this->width >= 8.0 && this->speedy > 0)
        this->speedy = 0.0;
    if(this->position.y > 1.0 && this->position.y + speedy < 1.0){
        this->position.y = 1.0;
        speedy = 0.0;
    }
    this->position.y += speedy;
    if(this->position.y + this->width >= 8.0)
        this->speedy = 0.0;
}
#include "main.h"

#ifndef RECTANGLE_H
#define RECTANGLE_H


class Rectangle {
public:
    Rectangle() {}
    Rectangle(float x, float y, float len, float width, float angle, float speedx, float speedy, color_t color);
    glm::vec3 position;
    void draw(glm::mat4 VP);
    void set_position(float x, float y);
    void tick();
    double speedx, speedy;
    float rotation, width, len;
private:
    VAO *object;
};

#endif // RECTANGLE_H
#version 330 core

// Interpolated values from the vertex shaders
in vec3 fragColor;

// output data
out vec3 color;

void main()
{
    // Output color = color specified in the vertex shader,
    // interpolated between all 3 surrounding vertices of the triangle
    color = fragColor;
}
#version 330 core

// input data : sent from main program
layout (location = 0) in vec3 vertexPosition;
layout (location = 1) in vec3 vertexColor;

uniform mat4 MVP;

// output data : used by fragment shader
out vec3 fragColor;

void main ()
{
    vec4 v = vec4(vertexPosition, 1); // Transform an homogeneous 4D vector

    // The color of each vertex will be interpolated
    // to produce the color of each fragment
    fragColor = vertexColor;

    // Output position of the vertex, in clip space : MVP * position
    gl_Position = MVP * v;
}
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include <algorithm>
#include "score.h"
#include "main.h"
#include "sevenseg.h"
using namespace std;

Score::Score(float x, float y) {
    this->x = x;
    this->y = y;
    this->Character[0] = SevenSeg(this->x, this->y);
    this->Character[1] = SevenSeg(this->x + 0.3, this->y);
    this->Character[2] = SevenSeg(this->x + 0.6, this->y);
    this->Character[3] = SevenSeg(this->x + 0.9, this->y);
    this->Character[4] = SevenSeg(this->x + 1.2, this->y);
    this->Character[5] = SevenSeg(this->x + 1.5, this->y);
    this->Character[6] = SevenSeg(this->x + 1.8, this->y);
    this->Character[7] = SevenSeg(this->x + 2.1, this->y);
    this->Character[8] = SevenSeg(this->x + 2.4, this->y);
    this->Character[9] = SevenSeg(this->x + 2.7, this->y);
    this->Character[10] = SevenSeg(this->x + 3.0, this->y);
    this->Character[11] = SevenSeg(this->x + 3.3, this->y);
}

void Score::draw(glm::mat4 VP) {
    for(int i=0; i < 12; i++)
        this->Character[i].draw(VP);
}

void Score::tick(float speedx, int score) {
    int dig;
    char c[6];
    for(int i=0; i<6; i++){
        dig = score%10;
        c[i] = dig + '0';
        score/=10;
    }
    this->speedx = speedx;
    this->Character[0].tick(speedx, 's');
    this->Character[1].tick(speedx, 'c'); 
    this->Character[2].tick(speedx, 'o'); 
    this->Character[3].tick(speedx, 'r'); 
    this->Character[4].tick(speedx, 'e'); 
    this->Character[5].tick(speedx, '-'); 
    this->Character[6].tick(speedx, c[5]); 
    this->Character[7].tick(speedx, c[4]); 
    this->Character[8].tick(speedx, c[3]); 
    this->Character[9].tick(speedx, c[2]); 
    this->Character[10].tick(speedx, c[1]); 
    this->Character[11].tick(speedx, c[0]); 
}
#include "main.h"
#include "sevenseg.h"

#ifndef SCORE_H
#define SCORE_H


class Score {
public:
    Score() {}
    Score(float x, float y);
    void draw(glm::mat4 VP);
    void tick(float speedx, int score);
    SevenSeg Character[12];
    float x, y, speedx;
private:
    VAO *object;
};

#endif // SCORE_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "semicircle.h"
#include "main.h"
using namespace std;

Semicircle::Semicircle(float x, float y, float radius, float speedx, float speedy, float rotation, color_t color) {
    this->position = glm::vec3(x, y, 0);
    this->rotation = rotation;
    this->speedx = speedx;
    this->speedy = speedy;
    this->radius = radius;
    const int n = 100;
    static GLfloat vertex_buffer_data[(9*n)/2] ;
    float r = radius;
    float angle = ( 2.0*M_PI / float(n));
    float theta = 0.0;
    for(int i=0;i<n/2;i++){
        vertex_buffer_data[9*i] = 0.0f;
        vertex_buffer_data[9*i + 1] = 0.0f;
        vertex_buffer_data[9*i + 2] = 0.0f;
        vertex_buffer_data[9*i + 3] = r*cos(theta);
        vertex_buffer_data[9*i + 4] = r*sin(theta);
        vertex_buffer_data[9*i + 5] = 0.0f;
        theta += angle;
        if(i == n-1){
            vertex_buffer_data[9*i + 6] = r;
            vertex_buffer_data[9*i + 7] = 0.0f;
            vertex_buffer_data[9*i + 8] = 0.0f;
        }
        else{
            vertex_buffer_data[9*i + 6] = r*cos(theta);
            vertex_buffer_data[9*i + 7] = r*sin(theta);
            vertex_buffer_data[9*i + 8] = 0.0f;
        }
        
    }
    this->object = create3DObject(GL_TRIANGLES, (3*n)/2, vertex_buffer_data, color, GL_FILL);
}

void Semicircle::draw(glm::mat4 VP) {
    Matrices.model = glm::mat4(1.0f);
    glm::mat4 translate = glm::translate (this->position);    // glTranslatef
    glm::mat4 rotate    = glm::rotate((float) (this->rotation * M_PI / 180.0f), glm::vec3(0, 0, 1));
    Matrices.model *= (translate * rotate);
    glm::mat4 MVP = VP * Matrices.model;
    glUniformMatrix4fv(Matrices.MatrixID, 1, GL_FALSE, &MVP[0][0]);
    draw3DObject(this->object);
}

void Semicircle::set_position(float x, float y) {
    this->position = glm::vec3(x, y, 0);
}

void Semicircle::tick() {
    if(this->position.y+speedy - this->radius >= 1.0 && this->position.y+speedy + this->radius <= 8.0){
        this->position.y += speedy;
    }
    if(this->position.y - this->radius > 1.0 && this->position.y + speedy - this->radius< 1.0){
        this->position.y = 1.0;
        speedy = 0.0;
    }
    this->position.x -= speedx;
    
}

#include "main.h"

#ifndef SEMICIRCLE_H
#define SEMICIRCLE_H


class Semicircle {
public:
    Semicircle() {}
    Semicircle(float x, float y, float radius, float speedx, float speedy, float rotation, color_t color);
    glm::vec3 position;
    float rotation;
    void draw(glm::mat4 VP);
    void set_position(float x, float y);
    void tick();
    float radius;
    double speedx, speedy;
private:
    VAO *object;
};

#endif // SEMICIRCLE_H
#define GLM_ENABLE_EXPERIMENTAL
#include <iostream>
#include <fstream>
#include "sevenseg.h"
#include "main.h"
using namespace std;

SevenSeg::SevenSeg(float x, float y) {
    this->on = "1111111";
    for(int i=0; i<7;i++)
        this->R[i] = Rectangle(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, COLOR_BLACK);
    this->x = x, this->y = y;
}

void SevenSeg::draw(glm::mat4 VP) {
    for(int i=0; i<7; i++)
        if(this->on[i] == '1')
            this->R[i].draw(VP);
}

void SevenSeg::tick(float speedx, char c) {
    this->speedx = speedx;
    this->c = c;
    if(c == '0' || c == 'o')
        this->on = "1111110";
    else if(c == '1')
        this->on = "0001100";
    else if(c == '2')
        this->on = "0110111";
    else if(c == '3')
        this->on = "0011111";
    else if(c == '4')
        this->on = "1001101";
    else if(c == '5' || c == 's')
        this->on = "1011011";
    else if(c == '6')
        this->on = "1111011";
    else if(c == '7')
        this->on = "0001110";
    else if(c == '8')
        this->on = "1111111";
    else if(c == '9')
        this->on = "1011111";
    else if(c == 'c')
        this->on = "1110010";
    else if(c == 'r')
        this->on = "1100010";
    else if(c == 'e')
        this->on = "1110011";
    else if(c == '-')
        this->on = "0000001";
    if(this->on[0] == '1')
        this->R[0] = Rectangle(x, y, 0.2, 0.03, -90.0, 0.0, 0.0, COLOR_BLACK);
    if(this->on[1] == '1')
        this->R[1] = Rectangle(x, y - 0.2, 0.2, 0.03, -90.0, 0.0, 0.0, COLOR_BLACK);
    if(this->on[2] == '1')
        this->R[2] = Rectangle(x, y - 0.4, 0.2, 0.03, 0.0, 0.0, 0.0, COLOR_BLACK);
    if(this->on[3] == '1')
        this->R[3] = Rectangle(x + 0.2 - 0.03, y - 0.2, 0.2, 0.03, -90.0, 0.0, 0.0, COLOR_BLACK);
    if(this->on[4] == '1')
        this->R[4] = Rectangle(x + 0.2 - 0.03, y, 0.2, 0.03, -90.0, 0.0, 0.0, COLOR_BLACK);
    if(this->on[5] == '1')
        this->R[5] = Rectangle(x, y, 0.2, 0.03, 0.0, 0.0, 0.0, COLOR_BLACK);
    if(this->on[6] == '1')
        this->R[6] = Rectangle(x, y - 0.2, 0.2, 0.03, 0.0, 0.0, 0.0, COLOR_BLACK);
    for(int i=0; i<7; i++)
        if(this->on[i] == 1){
            this->R[i].speedx = this->speedx;
            this->R[i].tick();
        }
}
#include "main.h"
#include "rectangle.h"
#include <string>

using namespace std;

#ifndef SEVENSEG_H
#define SEVENSEG_H


class SevenSeg {
public:
    SevenSeg() {}
    SevenSeg(float x, float y);
    void draw(glm::mat4 VP);
    void tick(float speedx, char c);
    Rectangle R[7];
    string on;
    float x, y, speedx;
    char c;
private:
    VAO *object;
};

#endif // SEVENSEG_H
#define GLM_ENABLE_EXPERIMENTAL
#include "timer.h"
#include <GLFW/glfw3.h>

Timer::Timer(double interval) {
    prev = 0;
    this->interval = interval;
}

bool Timer::processTick() {
    double cur = glfwGetTime();
    if (cur - prev >= interval) {
        prev = cur;
        return true;
    } else
        return false;
}
#ifndef TIMER_H
#define TIMER_H


class Timer {
public:
    Timer() {
        prev = 0;
    }
    Timer(double interval);
    double interval;
    bool processTick();
private:
    double prev;
};

#endif // TIMER_H
